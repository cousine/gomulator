package gboy

import (
	"bufio"
	"fmt"
	"os"
)

// Memory Sizes
const ROMSIZE = 0x7FFF
const WRAMSIZE = 0x2000
const ZRAMSIZE = 0x80

// Errors, Errors, Errors
type MemErrAddrOutOfBounds Address

func (e MemErrAddrOutOfBounds) Error() string {
	return fmt.Sprintf("MMU: Address %#010x is out of bounds", Address(e))
}

type MemErrLoadRomFailed string

func (e MemErrLoadRomFailed) Error() string {
	return fmt.Sprintf("MMU: Loading ROM file failed: %s", e)
}

// The meat!!
type MMU struct {
	_inbios                          bool
	_bios, _rom, _wram, _eram, _zram []byte
}

// Resets the MMU by loading the bios and clearing all memory banks
func (m *MMU) Reset() {
	m.LoadBios()
	m._inbios = true
	// Clear the memory!
	m._rom = make([]byte, 0, ROMSIZE)
	m._wram = make([]byte, 0, WRAMSIZE)
	m._eram = make([]byte, 0, WRAMSIZE)
	m._zram = make([]byte, 0, ZRAMSIZE)
}

// Load Skynet
// Not really.. its just GameBoy's Bios
func (m *MMU) LoadBios() {
	m._bios = []byte{
		0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
		0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
		0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
		0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
		0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
		0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
		0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
		0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
		0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xF2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
		0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
		0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
		0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
		0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
		0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3c, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x4C,
		0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
		0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50,
	}
}

// Loads a ROM into the memory
func (m *MMU) LoadRom(path string) error {
	rom, err := os.Open(path)
	if err != nil {
		return MemErrLoadRomFailed(err.Error())
	}

	defer rom.Close()

	info, err := rom.Stat()
	if err != nil {
		return MemErrLoadRomFailed(err.Error())
	}

	// NOTE: probably the size should be constant? or maybe this will error out if the rom file is smaller
	var size int64 = info.Size()
	m._rom = make([]byte, size)

	buffer := bufio.NewReader(rom)
	_, err = buffer.Read(m._rom)
	if err != nil {
		return MemErrLoadRomFailed(err.Error())
	}

	return nil
}

// Read 8-bit byte from addr
func (m *MMU) ReadByte(addr Address) (byte, error) {
	switch addr & 0xF000 {
	case 0x0000: // BIOS (256b)/ROM0
		if m._inbios {
			if addr < 0x0100 {
				return m._bios[addr], nil
			} else if z80._r.PC == 0x0100 {
				m._inbios = false
			}
		}
		return m._rom[addr], nil
	case 0x1000, 0x2000, 0x3000: // ROM0
		return m._rom[addr], nil
	case 0x4000, 0x5000, 0x6000, 0x7000: // ROM1 (unbanked 16k)
		return m._rom[addr], nil
	case 0x8000, 0x9000: // Graphics: VRAM (8k)
		return 0, nil // TODO: replace with GPU return
	case 0xA000, 0xB000: // External RAM (8k)
		return m._eram[addr&0x1FFF], nil
	case 0xC000, 0xD000, 0xE000: // Working RAM & Shadow (8k)
		return m._wram[addr&0x1FFF], nil
	case 0xF000: // Working RAM shadow, I/O, Zero-page RAM
		switch addr & 0x0F00 {
		case 0x000, 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0x700, 0x800, 0x900, 0xA00, 0xB00, 0xC00, 0xD00:
			return m._wram[addr&0x1FFF], nil
		case 0xE00: // Graphics: object attribute memory (OAM)
			// OAM is 160 bytes, the rest are read as 0
			if addr < 0xFEA0 {
				return 0, nil // TODO: replace with GPU OAM
			} else {
				return 0, nil
			}
		case 0xF00:
			if addr > 0xFF7F {
				return m._zram[addr&0x7F], nil
			} else {
				// I/O control handling
				// NOTE: Unhandled
				return 0, nil
			}
		}
	}

	return 0, MemErrAddrOutOfBounds(addr)
}

// Read 16-bit word from addr
func (m *MMU) ReadWord(addr Address) (Address, error) {
	byte1, error1 := m.ReadByte(addr)
	if error1 == nil {
		return 0, error1
	}

	byte2, error2 := m.ReadByte(addr + 1)
	if error2 == nil {
		return 0, error2
	}

	return CombineToAddress(byte1, byte2), nil
}

// Write 8-bit byte to addr
func (m *MMU) WriteByte(addr Address, value byte) error {
	switch addr & 0xF000 {
	case 0x0000, 0x1000, 0x2000, 0x3000: // BIOS (256b)/ROM0
		if m._inbios && addr < 0x0100 {
			return nil
		}
	case 0x4000, 0x5000, 0x6000, 0x7000: // ROM1 (unbanked 16k)
		return nil
	case 0x8000, 0x9000: // Graphics: VRAM (8k)
		return nil // TODO: replace with GPU return
	case 0xA000, 0xB000: // External RAM (8k)
		m._eram[addr&0x1FFF] = value
		return nil
	case 0xC000, 0xD000, 0xE000: // Working RAM (8k)
		m._wram[addr&0x1FFF] = value
		return nil
	case 0xF000: // Working RAM shadow, I/O, Zero-page RAM
		switch addr & 0x0F00 {
		case 0x000, 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0x700, 0x800, 0x900, 0xA00, 0xB00, 0xC00, 0xD00:
			m._wram[addr&0x1FFF] = value
			return nil
		case 0xE00: // Graphics: object attribute memory (OAM)
			// OAM is 160 bytes, the rest are read as 0
			if (addr & 0xFF) < 0xA0 {
				return nil // TODO: replace with GPU OAM
			}
		case 0xF00:
			if addr > 0xFF7F {
				m._zram[addr&0x7F] = value
				return nil
			} else {
				// I/O control handling
				// NOTE: Unhandled
				return nil
			}
		}
	}

	return MemErrAddrOutOfBounds(addr)
}

// Write 16-bit word to addr
func (m *MMU) WriteWord(addr, value Address) error {
	error1 := m.WriteByte(addr, byte(value))
	if error1 != nil {
		return error1
	}

	error2 := m.WriteByte(addr+1, byte(value>>8))
	if error2 != nil {
		return error2
	}

	return nil
}
